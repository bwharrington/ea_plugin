"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorClient = void 0;
const commandtypes_1 = require("./commandtypes");
const base64_1 = require("./core/base64");
const blockproxyregistry_1 = require("./document/blockclasses/blockproxyregistry");
const blockproxy_1 = require("./document/blockproxy");
const documentproxy_1 = require("./document/documentproxy");
const elementproxy_1 = require("./document/elementproxy");
const groupproxy_1 = require("./document/groupproxy");
const lineproxy_1 = require("./document/lineproxy");
const pageproxy_1 = require("./document/pageproxy");
class EditorClient {
    constructor() {
        this.nextId = 0;
        this.callbacks = new Map();
        this.listenToEditor();
    }
    getUniqueActionName() {
        while (this.actionExists('a' + this.nextId)) {
            this.nextId++;
        }
        return 'a' + this.nextId;
    }
    /**
     * Unload this extension immediately, removing any custom menu items etc., until the user refreshes the browser tab.
     */
    killExtension() {
        this.sendCommand("k" /* KillExtension */, undefined);
    }
    /**
     * Unload this extension, and then re-execute it.
     */
    reloadExtension() {
        this.sendCommand("r" /* ReloadExtension */, undefined);
    }
    /**
     * Initiate a browser file download of custom content
     * @param filename Filename of the downloaded file
     * @param data The content to put into the file, either in plain text or as base64-encoded binary data
     * @param mime The MIME type to tell the browser it is downloading
     * @param base64 If true, base64 decode the data before downloading it
     */
    download(filename, data, mime, base64) {
        this.sendCommand("d" /* Download */, {
            'f': filename,
            'd': data,
            'm': mime,
            'b64': base64,
        });
    }
    /**
     *
     * @param flowName
     * @param dataConnectorName
     * @param syncDataSourceId
     * @param flowData
     * @param async
     * @returns
     * @throws A string with an error from the data sync server
     */
    async performDataAction(flowName, dataConnectorName, syncDataSourceId = undefined, flowData = undefined, async = true) {
        const result = await this.sendCommand("da" /* DataAction */, {
            'fn': flowName,
            'a': async,
            's': syncDataSourceId,
            'fd': flowData,
            'n': dataConnectorName,
        });
        if ('t' in result) {
            return {
                'status': result['c'],
                'text': result['t'],
            };
        }
        return {
            'status': result['c'],
            'json': result['j'],
        };
    }
    /**
     * Make a network request
     * @param request Settings for the network request
     * @returns A promise that will either resolve or reject with an XHRResponse. If the HTTP status
     *   code is not 2xx, the promise will reject.
     */
    xhr(request) {
        return this.sendCommand("xhr" /* SendXHR */, {
            'url': request.url,
            'm': request.method,
            'd': request.data,
            'h': request.headers,
            'ms': request.timeoutMs,
        })
            .then((raw) => {
            return {
                url: raw['url'],
                responseText: raw['t'],
                status: raw['s'],
                headers: raw['h'],
                timeout: raw['to'],
            };
        })
            .catch((error) => {
            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;
            throw {
                url: raw ? raw['url'] : '',
                responseText: raw ? raw['t'] : 'An unknown error occurred',
                status: raw ? raw['s'] : 0,
                headers: raw ? raw['h'] : {},
                timeout: raw ? raw['to'] : undefined,
            };
        });
    }
    oauthXhr(providerName, request) {
        return this.sendCommand("oauth" /* SendOAuthRequest */, {
            'url': request.url,
            'm': request.method,
            'd': request.data,
            'h': request.headers,
            'ms': request.timeoutMs,
            'p': providerName,
        })
            .then((raw) => {
            return {
                url: raw['url'],
                responseText: raw['t'],
                status: raw['s'],
                headers: raw['h'],
                timeout: raw['to'],
            };
        })
            .catch((error) => {
            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : error;
            throw {
                url: raw['url'],
                responseText: raw['t'],
                status: raw['s'],
                headers: raw['h'],
                timeout: raw['to'],
            };
        });
    }
    /**
     * Register a named action. These actions can be triggered from custom UI, for example as the action of a
     * custom menu item.
     *
     * Some actions may return a value that is used by the core application, e.g. a `visibleAction` for a menu
     * item. However, if you return a `Promise` from your callback, that value will be discarded and your
     * action will return `undefined` instead. The ability to provide a callback that returns a Promise is only
     * a convenience so that you can register actions with `async` callbacks for easy async/await.
     *
     * Throws an error if the same action name is registered multiple times.
     *
     * @param name name of the action
     * @param callback function to execute when this action is invoked
     */
    registerAction(name, callback) {
        if (this.actionExists(name)) {
            throw new Error('Action already exists: ' + name);
        }
        this.callbacks.set(name, callback);
    }
    /**
     * Register a named action that receives file upload data. These callbacks can be used in
     * Menu.addMenuItem as the file action.
     * @param name The name of the action
     * @param callback Function to execute when this action is invoked
     */
    registerFileUploadAction(name, callback) {
        this.registerAction(name, (msg) => {
            callback(msg['f'].map((rawFile) => {
                if (rawFile['b']) {
                    return { fileName: rawFile['n'], text: rawFile['t'], binary: (0, base64_1.decodeBase64)(rawFile['b']) };
                }
                else {
                    return { fileName: rawFile['n'], text: rawFile['t'] };
                }
            }));
        });
    }
    /**
     * Remove the callback for a given action. If the action is later invoked, nothing will happen.
     * @param name name of the action to unregister
     */
    deleteAction(name) {
        this.callbacks.delete(name);
    }
    /**
     * @param name name of the action to check
     * @returns true if a callback has been registered for this action; false otherwise
     */
    actionExists(name) {
        return this.callbacks.has(name);
    }
    //Note: UnionToIntersection here fixes the type of params required if you're passing in something that's not a single
    //specific command name, to require the type of all possible command names you could pass in, intersected. So if you
    //call this with a CommandName.ListBlocks|CommandName.ListLines it will work as expected but if you just pass in a
    //CommandName, there won't be any possible params you could pass that would meet all the requirements (string & undefined & ...)
    /**
     * Execute an API command. This is the low-level API that most of this SDK wraps. It is not expected that you should
     * ever need to use this directly.
     *
     * @param name name of the API command to execute
     * @param params data to pass to the API command
     * @returns the output of the given API command
     */
    sendCommand(name, params) {
        return lucid.executeCommand(name, params);
    }
    /**
     * Create and return a proxy for accessing a block with the given ID. If the block is of a type that has a specific
     * proxy implementation (e.g. an ERD block) then a specialized subclass of BlockProxy may be returned.
     *
     * @param id ID of the block to create a proxy for
     * @returns the given block
     */
    getBlockProxy(id) {
        const className = this.sendCommand("gp" /* GetProperty */, { 'id': id, 'p': 'ClassName' });
        const proxy = (0, blockproxyregistry_1.findProxyClass)(className);
        if (proxy) {
            return new proxy(id, this);
        }
        else {
            return new blockproxy_1.BlockProxy(id, this);
        }
    }
    /**
     * Because code for block classes are loaded incrementally, you MUST call
     * loadBlockClasses with the given block class name (and wait for it to
     * resolve) before attempting to create a block. If you don't, an error
     * will be thrown.
     *
     * @param classNames the block classes to load
     * @returns a promise that resolves when the block classes can be used to create new blocks on the document
     */
    loadBlockClasses(classNames) {
        return this.sendCommand("lbc" /* LoadBlockClasses */, classNames);
    }
    /**
     * Load the requested shape library's content, and if it was found, return a block definition ready to be
     * created.
     *
     * Example usage:
     * ```inline:typescript
     * const client = new EditorClient();
     * const viewport = new Viewport(client);
     *
     * const page = viewport.getCurrentPage();
     * if (page) {
     *     const def = await page.getCustomShapeDefinition('libraryName', 'shapeName');
     *     if (def) {
     *         //Customize the shape about to be created
     *         def.boundingBox.x = 500;
     *         def.boundingBox.y = 500;
     *
     *         //Create the shape itself
     *         const block = page.addBlock(def);
     *
     *         //Set any data fields on the shape as needed
     *         block.shapeData.set('Value', 50);
     *     }
     * }
     * ```
     * @param library Name of the shape library in this extension to search for
     * @param shape Name of the shape within that library to search for
     * @returns
     */
    async getCustomShapeDefinition(library, shape) {
        await this.loadBlockClasses(['CustomBlock']);
        const shapeData = await this.sendCommand("gcs" /* GetCustomShape */, { 'l': library, 's': shape });
        if (shapeData) {
            return {
                className: 'CustomBlock',
                boundingBox: shapeData['bb'],
                stencil: shapeData['s'],
                properties: shapeData['p'],
            };
        }
        return undefined;
    }
    /**
     * @param callback A callback that processes the bootstrap data, if any, stored on the document and
     * associated with this editor extension. If this callback is async (returns a promise), then the
     * bootstrap data is not cleared off of the document until that promise resolves.
     *
     * @param markExtensionAsRequired If bootstrap data is available for this editor extension, this will mark the
     * document as requiring the extension. Once marked, if the extension is not installed the user will be
     * notified about the extension being required on document load. The minimum extension version required by the
     * document is the version provided in the request body when creating the document.
     *
     * @return a promise that resolves immediately if there is no available bootstrap data, or else after
     * the callback successfully completes. This promise will reject/throw if the callback throws or
     * returns a promise that rejects, or if there is another editor session processing the same bootstrap
     * data at the same time.
     */
    async processAndClearBootstrapData(callback, markExtensionAsRequired) {
        const name = this.getUniqueActionName();
        this.registerAction(name, (msg) => {
            return callback(msg['d']);
        });
        await this.sendCommand("b" /* Bootstrap */, { 'c': name, 'm': markExtensionAsRequired });
        this.deleteAction(name);
    }
    /**
     * @param id ID of the line to create a proxy for
     * @returns the given line
     */
    getLineProxy(id) {
        return new lineproxy_1.LineProxy(id, this);
    }
    /**
     * @param id ID of the page to create a proxy for
     * @returns the given page
     */
    getPageProxy(id) {
        return new pageproxy_1.PageProxy(id, this);
    }
    /**
     * @param id ID of the item to create a proxy for
     * @returns the given item
     */
    getItemProxy(id) {
        const type = this.sendCommand("get" /* GetElementType */, { 'id': id });
        switch (type) {
            case 'block':
                return this.getBlockProxy(id);
            case 'line':
                return this.getLineProxy(id);
            case 'group':
                return new groupproxy_1.GroupProxy(id, this);
            default:
                throw new Error('Element ' + id + ' is not an Item; type found is ' + type);
        }
    }
    /**
     * @param id ID of the element to create a proxy for
     * @returns the given element
     */
    getElementProxy(id) {
        const type = this.sendCommand("get" /* GetElementType */, { 'id': id });
        switch (type) {
            case 'block':
                return this.getBlockProxy(id);
            case 'line':
                return this.getLineProxy(id);
            case 'page':
                return this.getPageProxy(id);
            case 'document':
                return new documentproxy_1.DocumentProxy(this);
            case 'group':
                return new groupproxy_1.GroupProxy(id, this);
            default:
                return new elementproxy_1.ElementProxy(id, this);
        }
    }
    /**
     * @hidden
     */
    listenToEditor() {
        lucid.listen((msg) => {
            var _a;
            return (_a = this.callbacks.get(msg['id'])) === null || _a === void 0 ? void 0 : _a(msg);
        });
    }
    /**
     * Display an alert modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @param buttonText Text for the OK button; defaults to "OK" (or a translation)
     * @returns a Promise that resolves true if the user clicks OK, false if they otherwise dismiss the modal
     */
    alert(text, title, buttonText) {
        return this.sendCommand("a" /* Alert */, { 't': title, 'b': text, 'bt': buttonText });
    }
    /**
     * Display a confirm modal to the user
     * @param text Body text to display in the alert modal
     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json
     * @param okText Text for the OK button; defaults to "OK" (or a translation)
     * @param cancelText Text for the Cancel button; defaults to "Cancel" (or a translation)
     * @returns a Promise that resolves true if the user clicks OK, false if they click Cancel or otherwise dismiss the modal
     */
    confirm(text, title, okText, cancelText) {
        return this.sendCommand("c" /* Confirm */, { 't': title, 'b': text, 'o': okText, 'c': cancelText });
    }
}
exports.EditorClient = EditorClient;
