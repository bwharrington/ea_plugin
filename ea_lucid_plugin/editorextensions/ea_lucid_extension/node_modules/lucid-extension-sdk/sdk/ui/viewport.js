"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Viewport = void 0;
const checks_1 = require("../core/checks");
const itemproxy_1 = require("../document/itemproxy");
const pageproxy_1 = require("../document/pageproxy");
const math_1 = require("../math");
class Viewport {
    constructor(client) {
        this.client = client;
    }
    static nextHookName() {
        return '__viewport__hook' + Viewport.nextHookId++;
    }
    /**
     * @param deep If true, and groups are selected, include the contents of those groups in the array
     * @returns An array of currently-selected items on the currently-visible page
     */
    getSelectedItems(deep) {
        const ids = this.client.sendCommand("gs" /* GetSelection */, { 'd': deep });
        return ids
            .map((id) => this.client.getElementProxy(id))
            .filter((proxy) => proxy instanceof itemproxy_1.ItemProxy);
    }
    /**
     * @returns the page currently being viewed
     */
    getCurrentPage() {
        const id = this.client.sendCommand("gcp" /* GetCurrentPage */, undefined);
        return id == null ? id : new pageproxy_1.PageProxy(id, this.client);
    }
    /**
     * View the given page in the viewport
     * @param page The page to view
     */
    setCurrentPage(page) {
        this.client.sendCommand("scp" /* SetCurrentPage */, page.id);
    }
    /**
     * Switch to the page containing these items, if necessary, and then animate the viewport
     * to zoom in and focus on these items.
     * @param items The items the camera should zoom to
     */
    focusCameraOnItems(items) {
        const bb = (0, math_1.combinedBoundingBox)(items.map((e) => e.getBoundingBox()));
        if (bb) {
            //TODO: A reasonable max zoom level (e.g. 200%)
            this.client.sendCommand("av" /* AnimateViewport */, {
                'bb': (0, math_1.padBox)(bb, 80),
                'p': items[0].getPage().id,
            });
        }
    }
    /**
     * If `callback` returns false, text editing is prevented.
     * If `callback` returns true, text editing continues as normal.
     *
     * If `callback` returns a [TextEditCompletionCallback](/extension-sdk/#modules_ui_viewport_texteditcompletioncallback), then text editing
     * is allowed, but that completion callback is called
     * when the user finishes editing that text. That completion callback may return true or false to allow or deny the edit, or
     * also may return a replacement string to use instead of the text the user actually typed. If replacement text is provided,
     * it will be styled as close to the original as possible, but styles that apply to only parts of the original text will be
     * discarded.
     *
     * @param callback Called just before the user starts editing text.
     *
     * @returns A handle representing this hook, which can be passed to unhookTextEdit to remove this hook.
     */
    hookTextEdit(callback) {
        const actionName = Viewport.nextHookName();
        this.client.registerAction(actionName, async (textHookParam) => {
            const element = this.client.getElementProxy(textHookParam['i']);
            if (element instanceof itemproxy_1.ItemProxy) {
                const result = await callback(element, textHookParam['t']);
                if ((0, checks_1.isBoolean)(result)) {
                    return result;
                }
                else {
                    const completeName = Viewport.nextHookName();
                    this.client.registerAction(completeName, (textCompleteParam) => {
                        this.client.deleteAction(completeName);
                        return result(textCompleteParam['v']);
                    });
                    return completeName;
                }
            }
            else {
                //Shouldn't be possible, but just in case allow text editing as normal
                return true;
            }
        });
        this.client.sendCommand("hte" /* HookTextEdit */, { 'n': actionName });
        return actionName;
    }
    /**
     * Remove a hook set by hookTextEdit.
     *
     * @param handle The return value of hookTextEdit.
     */
    unhookTextEdit(handle) {
        this.client.deleteAction(handle);
        this.client.sendCommand("ute" /* UnhookTextEdit */, { 'n': handle });
    }
    /**
     * @param callback Called when the user changes their selection of items
     *
     * @returns A handle representing this hook, which can be passed to unhookSelection to remove this hook.
     */
    hookSelection(callback) {
        const actionName = Viewport.nextHookName();
        this.client.registerAction(actionName, async (param) => {
            const elements = param['ids']
                .map((id) => this.client.getElementProxy(id))
                .filter((element) => element instanceof itemproxy_1.ItemProxy);
            callback(elements);
        });
        this.client.sendCommand("hs" /* HookSelection */, { 'n': actionName });
        return actionName;
    }
    /**
     * Remove a hook set by hookSelection.
     *
     * @param handle The return value of hookSelection.
     */
    unhookSelection(handle) {
        this.client.deleteAction(handle);
        this.client.sendCommand("us" /* UnhookSelection */, { 'n': handle });
    }
}
exports.Viewport = Viewport;
Viewport.nextHookId = 0;
