import { ItemProxy } from '../document/itemproxy';
import { PageProxy } from '../document/pageproxy';
import { EditorClient } from '../editorclient';
/**
 * A text editing hook provided to [Viewport.hookTextEdit](/extension-sdk/#classes_ui_viewport-Viewport_hooktextedit)
 * may return a TextEditCompletionCallback to specify what behavior should happen when the user finishes editing text.
 *
 * If this callback returns false, the edit is reverted.
 *
 * If this callback returns a string, the typed value is replaced with that string.
 */
export declare type TextEditCompletionCallback = (newValue: string) => boolean | string | Promise<boolean | string>;
export declare class Viewport {
    private readonly client;
    private static nextHookId;
    constructor(client: EditorClient);
    private static nextHookName;
    /**
     * @param deep If true, and groups are selected, include the contents of those groups in the array
     * @returns An array of currently-selected items on the currently-visible page
     */
    getSelectedItems(deep?: boolean): ItemProxy[];
    /**
     * @returns the page currently being viewed
     */
    getCurrentPage(): PageProxy | undefined;
    /**
     * View the given page in the viewport
     * @param page The page to view
     */
    setCurrentPage(page: PageProxy): void;
    /**
     * Switch to the page containing these items, if necessary, and then animate the viewport
     * to zoom in and focus on these items.
     * @param items The items the camera should zoom to
     */
    focusCameraOnItems(items: ItemProxy[]): void;
    /**
     * If `callback` returns false, text editing is prevented.
     * If `callback` returns true, text editing continues as normal.
     *
     * If `callback` returns a [TextEditCompletionCallback](/extension-sdk/#modules_ui_viewport_texteditcompletioncallback), then text editing
     * is allowed, but that completion callback is called
     * when the user finishes editing that text. That completion callback may return true or false to allow or deny the edit, or
     * also may return a replacement string to use instead of the text the user actually typed. If replacement text is provided,
     * it will be styled as close to the original as possible, but styles that apply to only parts of the original text will be
     * discarded.
     *
     * @param callback Called just before the user starts editing text.
     *
     * @returns A handle representing this hook, which can be passed to unhookTextEdit to remove this hook.
     */
    hookTextEdit(callback: (item: ItemProxy, textAreaKey: string) => boolean | TextEditCompletionCallback | Promise<boolean | TextEditCompletionCallback>): string;
    /**
     * Remove a hook set by hookTextEdit.
     *
     * @param handle The return value of hookTextEdit.
     */
    unhookTextEdit(handle: string): void;
    /**
     * @param callback Called when the user changes their selection of items
     *
     * @returns A handle representing this hook, which can be passed to unhookSelection to remove this hook.
     */
    hookSelection(callback: (items: ItemProxy[]) => void): string;
    /**
     * Remove a hook set by hookSelection.
     *
     * @param handle The return value of hookSelection.
     */
    unhookSelection(handle: string): void;
}
