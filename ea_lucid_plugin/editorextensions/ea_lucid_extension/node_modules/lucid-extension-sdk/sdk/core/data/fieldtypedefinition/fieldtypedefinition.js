"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSerializedFieldTypeDefinition = exports.SerializedAnyFieldType = exports.deserializeFieldTypeDefinition = exports.serializeFieldTypeDefinition = exports.isAnyFieldType = exports.AnyFieldType = exports.isSubtypeOfFieldType = exports.fieldTypesEqual = void 0;
const checks_1 = require("../../checks");
const basefieldtypedefinition_1 = require("./basefieldtypedefinition");
const collectionenumfieldtype_1 = require("./collectionenumfieldtype");
const fieldtypearray_1 = require("./fieldtypearray");
const literalfieldtype_1 = require("./literalfieldtype");
const ndimensionalfieldtypearray_1 = require("./ndimensionalfieldtypearray");
const scalarfieldtype_1 = require("./scalarfieldtype");
function fieldTypesEqual(a, b, checkEnumCollectionId = true) {
    if (a === b) {
        return true;
    }
    if ((0, literalfieldtype_1.isLiteralFieldType)(a) && (0, literalfieldtype_1.isLiteralFieldType)(b)) {
        return a.getLiteral() === b.getLiteral();
    }
    if ((0, collectionenumfieldtype_1.isCollectionEnumFieldType)(a) && (0, collectionenumfieldtype_1.isCollectionEnumFieldType)(b)) {
        return checkEnumCollectionId ? a.collectionId === b.collectionId : true;
    }
    a = (0, checks_1.isArray)(a) ? a : [a];
    b = (0, checks_1.isArray)(b) ? b : [b];
    const setA = new Set(a);
    const setB = new Set(b);
    if (setA.size !== setB.size) {
        return false;
    }
    for (const bItem of setB) {
        if (setA.has(bItem)) {
            continue;
        }
        if ((0, literalfieldtype_1.isLiteralFieldType)(bItem)) {
            const found = a.some((aItem) => (0, literalfieldtype_1.isLiteralFieldType)(aItem) && fieldTypesEqual(aItem, bItem));
            if (!found) {
                return false;
            }
        }
        else if (bItem instanceof fieldtypearray_1.FieldTypeArray) {
            const found = a.some((aItem) => aItem instanceof fieldtypearray_1.FieldTypeArray && fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray));
            if (!found) {
                return false;
            }
        }
        else if ((0, ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray)(bItem)) {
            const aItem = a.find(ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray);
            if (!aItem || !fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray)) {
                return false;
            }
        }
        else {
            return false;
        }
    }
    return true;
}
exports.fieldTypesEqual = fieldTypesEqual;
function isSubtypeOfFieldType(subType, superTypes) {
    if (!(0, checks_1.isArray)(superTypes)) {
        superTypes = [superTypes];
    }
    if ((0, checks_1.isArray)(subType)) {
        return subType.every((one) => isSubtypeOfFieldType(one, superTypes));
    }
    if (superTypes.includes(scalarfieldtype_1.ScalarFieldTypeEnum.ANY)) {
        return true;
    }
    if ((0, scalarfieldtype_1.isScalarFieldTypeEnum)(subType)) {
        return superTypes.includes(subType);
    }
    if ((0, literalfieldtype_1.isLiteralFieldType)(subType)) {
        if (superTypes.includes(subType.getScalarFieldType())) {
            return true;
        }
        const superLiteralTypes = superTypes.filter(literalfieldtype_1.isLiteralFieldType);
        if (superLiteralTypes.find((superLiteralType) => subType.getLiteral() === superLiteralType.getLiteral())) {
            return true;
        }
        const superArrayTypes = superTypes.filter(basefieldtypedefinition_1.isAnyFieldTypeArray);
        for (const superArrayType of superArrayTypes) {
            if (isSubtypeOfFieldType(subType, superArrayType.getInnerTypes())) {
                return true;
            }
        }
        return false;
    }
    if ((0, collectionenumfieldtype_1.isCollectionEnumFieldType)(subType)) {
        return superTypes.filter(collectionenumfieldtype_1.isCollectionEnumFieldType).some((ce) => ce.collectionId === subType.collectionId);
    }
    if ((0, ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray)(subType)) {
        const superNArrayTypes = superTypes.filter(ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray);
        return !!superNArrayTypes.find((superNArrayType) => isSubtypeOfFieldType(subType.validTypesArray, superNArrayType.validTypesArray));
    }
    const subTypeArrayInnerTypes = subType.getInnerTypes();
    const superArrayTypes = superTypes.filter(basefieldtypedefinition_1.isAnyFieldTypeArray);
    for (const superArrayType of superArrayTypes) {
        if (isSubtypeOfFieldType(subTypeArrayInnerTypes, superArrayType.getInnerTypes())) {
            return true;
        }
    }
    return false;
}
exports.isSubtypeOfFieldType = isSubtypeOfFieldType;
exports.AnyFieldType = [...scalarfieldtype_1.AnyScalarFieldType, new ndimensionalfieldtypearray_1.NDimensionalFieldTypeArray(scalarfieldtype_1.AnyScalarFieldType)];
function isAnyFieldType(type) {
    let nArray;
    if (type === scalarfieldtype_1.ScalarFieldTypeEnum.ANY ||
        type === exports.AnyFieldType ||
        ((0, checks_1.isArray)(type) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.STRING) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.COLOR) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.DATE) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.NULL) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.DICTIONARY) &&
            type.includes(scalarfieldtype_1.ScalarFieldTypeEnum.CURRENCY) &&
            !type.some(literalfieldtype_1.isLiteralFieldType) &&
            (nArray = type.find(ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray)) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.STRING) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.COLOR) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.DATE) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.DICTIONARY) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.NULL) &&
            nArray.validTypesArray.includes(scalarfieldtype_1.ScalarFieldTypeEnum.CURRENCY) &&
            !nArray.validTypesArray.some(literalfieldtype_1.isLiteralFieldType))) {
        return true;
    }
    return false;
}
exports.isAnyFieldType = isAnyFieldType;
const serializeFieldTypeDefinition = (fieldType) => {
    if ((0, checks_1.isArray)(fieldType)) {
        return fieldType.map(basefieldtypedefinition_1.serializeBaseFieldTypeDefinition);
    }
    else {
        return (0, basefieldtypedefinition_1.serializeBaseFieldTypeDefinition)(fieldType);
    }
};
exports.serializeFieldTypeDefinition = serializeFieldTypeDefinition;
const deserializeFieldTypeDefinition = (serializedFieldType) => {
    if ((0, checks_1.isArray)(serializedFieldType)) {
        return serializedFieldType.map(basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition);
    }
    return (0, basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition)(serializedFieldType);
};
exports.deserializeFieldTypeDefinition = deserializeFieldTypeDefinition;
exports.SerializedAnyFieldType = (0, exports.serializeFieldTypeDefinition)(exports.AnyFieldType);
function isSerializedFieldTypeDefinition(definition) {
    if ((0, checks_1.isArray)(definition)) {
        return definition.every(basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition);
    }
    return (0, basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition)(definition);
}
exports.isSerializedFieldTypeDefinition = isSerializedFieldTypeDefinition;
