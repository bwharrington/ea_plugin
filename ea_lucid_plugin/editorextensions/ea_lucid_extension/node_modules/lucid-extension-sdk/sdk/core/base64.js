"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBase64 = void 0;
const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
//This gives a ~8x speedup vs. using alphabet.indexOf() in the main decode loop.
const charCodeToEncodedInt = [];
for (let i = 0; i < alphabet.length; i++) {
    charCodeToEncodedInt[alphabet.charCodeAt(i)] = i;
}
function decodeBase64(base64String) {
    //Filter out whitespace, etc
    base64String = base64String.replace(/[^A-Za-z0-9\+\/\=]/g, '');
    if (base64String.length % 4 !== 0) {
        throw new Error('Invalid base64 input; length must be a multiple of 4');
    }
    //4 characters of input turns into 3 bytes of output
    let bytes = (base64String.length / 4) * 3;
    //But each trailing = (up to 2) is one fewer byte of output
    if (base64String.endsWith('==')) {
        bytes -= 2;
    }
    else if (base64String.endsWith('=')) {
        bytes -= 1;
    }
    const output = new Uint8Array(bytes);
    let inputIndex = 0;
    for (let outputIndex = 0; outputIndex < bytes; outputIndex += 3) {
        //Get the 4 numbers 0-63 encoded in the next 4 characters
        const enc1 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        const enc2 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        const enc3 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        const enc4 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];
        //Read 8 total bits into each of the output values. Skip one byte
        //for each padding = at the end of the string
        output[outputIndex] = (enc1 << 2) | (enc2 >> 4);
        if (enc3 != 64) {
            output[outputIndex + 1] = ((enc2 & 15) << 4) | (enc3 >> 2);
        }
        if (enc4 != 64) {
            output[outputIndex + 2] = ((enc3 & 3) << 6) | enc4;
        }
    }
    return output;
}
exports.decodeBase64 = decodeBase64;
